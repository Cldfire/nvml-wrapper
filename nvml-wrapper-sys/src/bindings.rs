/* automatically generated by rust-bindgen 0.59.2 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::os::raw;

pub const NVML_API_VERSION: u32 = 11;
pub const NVML_API_VERSION_STR: &[u8; 3usize] = b"11\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &[u8; 17usize] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &[u8; 17usize] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 12;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const nvmlFlagDefault: u32 = 0;
pub const nvmlFlagForce: u32 = 1;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_DEVICE_ARCH_KEPLER: u32 = 2;
pub const NVML_DEVICE_ARCH_MAXWELL: u32 = 3;
pub const NVML_DEVICE_ARCH_PASCAL: u32 = 4;
pub const NVML_DEVICE_ARCH_VOLTA: u32 = 5;
pub const NVML_DEVICE_ARCH_TURING: u32 = 6;
pub const NVML_DEVICE_ARCH_AMPERE: u32 = 7;
pub const NVML_DEVICE_ARCH_UNKNOWN: u32 = 4294967295;
pub mod field_id {
    pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
    pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
    pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
    pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
    pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
    pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
    pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
    pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
    pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
    pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
    pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
    pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
    pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
    pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
    pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
    pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
    pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
    pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
    pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
    pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
    pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
    pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
    pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
    pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
    pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
    pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
    pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
    pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 96;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 97;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 98;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 99;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 100;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 101;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 102;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 103;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 104;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 105;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 106;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 107;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 108;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 109;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 110;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 111;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 112;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 113;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 114;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 115;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 116;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 117;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 118;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 119;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6: u32 = 120;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7: u32 = 121;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8: u32 = 122;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9: u32 = 123;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10: u32 = 124;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11: u32 = 125;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6: u32 = 126;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7: u32 = 127;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8: u32 = 128;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9: u32 = 129;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10: u32 = 130;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11: u32 = 131;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6: u32 = 132;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7: u32 = 133;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8: u32 = 134;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9: u32 = 135;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10: u32 = 136;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11: u32 = 137;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX: u32 = 138;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX: u32 = 139;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX: u32 = 140;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX: u32 = 141;
    pub const NVML_FI_DEV_REMAPPED_COR: u32 = 142;
    pub const NVML_FI_DEV_REMAPPED_UNC: u32 = 143;
    pub const NVML_FI_DEV_REMAPPED_PENDING: u32 = 144;
    pub const NVML_FI_DEV_REMAPPED_FAILURE: u32 = 145;
    pub const NVML_FI_MAX: u32 = 146;
}
pub const nvmlEventTypeSingleBitEccError: u32 = 1;
pub const nvmlEventTypeDoubleBitEccError: u32 = 2;
pub const nvmlEventTypePState: u32 = 4;
pub const nvmlEventTypeXidCriticalError: u32 = 8;
pub const nvmlEventTypeClock: u32 = 16;
pub const nvmlEventTypePowerSourceChange: u32 = 128;
pub const nvmlEventMigConfigChange: u32 = 256;
pub const nvmlEventTypeNone: u32 = 0;
pub const nvmlEventTypeAll: u32 = 415;
pub const nvmlClocksThrottleReasonGpuIdle: u32 = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: u32 = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: u32 = 8;
pub const nvmlClocksThrottleReasonSyncBoost: u32 = 16;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonHwThermalSlowdown: u32 = 64;
pub const nvmlClocksThrottleReasonHwPowerBrakeSlowdown: u32 = 128;
pub const nvmlClocksThrottleReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksThrottleReasonNone: u32 = 0;
pub const nvmlClocksThrottleReasonAll: u32 = 511;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_UUID_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
pub const NVML_AFFINITY_SCOPE_NODE: u32 = 0;
pub const NVML_AFFINITY_SCOPE_SOCKET: u32 = 1;
pub const NVML_DEVICE_MIG_DISABLE: u32 = 0;
pub const NVML_DEVICE_MIG_ENABLE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_GPU_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_GPU_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_GPU_INSTANCE_PROFILE_COUNT: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_COMPUTE_INSTANCE_PROFILE_COUNT: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [raw::c_char; 16usize],
    pub domain: raw::c_uint,
    pub bus: raw::c_uint,
    pub device: raw::c_uint,
    pub pciDeviceId: raw::c_uint,
    pub pciSubSystemId: raw::c_uint,
    pub busId: [raw::c_char; 32usize],
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: raw::c_ulonglong,
    pub l2Cache: raw::c_ulonglong,
    pub deviceMemory: raw::c_ulonglong,
    pub registerFile: raw::c_ulonglong,
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUtilization_st {
    pub gpu: raw::c_uint,
    pub memory: raw::c_uint,
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlMemory_st {
    pub total: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: raw::c_ulonglong,
    pub bar1Free: raw::c_ulonglong,
    pub bar1Used: raw::c_ulonglong,
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessInfo_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDeviceAttributes_st {
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = 0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = 1;
pub type nvmlBridgeChipType_enum = raw::c_uint;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
    nvmlNvLinkUtilizationCountUnits_enum = 0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
    nvmlNvLinkUtilizationCountUnits_enum = 1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
    nvmlNvLinkUtilizationCountUnits_enum = 2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_RESERVED:
    nvmlNvLinkUtilizationCountUnits_enum = 3;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
    nvmlNvLinkUtilizationCountUnits_enum = 4;
pub type nvmlNvLinkUtilizationCountUnits_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
    nvmlNvLinkUtilizationCountPktTypes_enum = 1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
    nvmlNvLinkUtilizationCountPktTypes_enum = 2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
    nvmlNvLinkUtilizationCountPktTypes_enum = 4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
    nvmlNvLinkUtilizationCountPktTypes_enum = 32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
    nvmlNvLinkUtilizationCountPktTypes_enum = 255;
pub type nvmlNvLinkUtilizationCountPktTypes_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum = 0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum = 1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = 2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum = 3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = 4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = 5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = 6;
pub type nvmlNvLinkCapability_enum = raw::c_uint;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum = 0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = 4;
pub type nvmlNvLinkErrorCounter_enum = raw::c_uint;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
pub type nvmlGpuLevel_enum = raw::c_uint;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = 4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = 6;
pub type nvmlGpuP2PStatus_enum = raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = 0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = 1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = 2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = 3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = 4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = 5;
pub type nvmlGpuP2PCapsIndex_enum = raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: raw::c_uint,
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = 0;
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 1;
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 2;
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 3;
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 4;
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = 5;
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = 6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = 7;
pub type nvmlSamplingType_enum = raw::c_uint;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = 0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = 1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = 2;
pub type nvmlPcieUtilCounter_enum = raw::c_uint;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = 1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = 2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = 3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = 4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 5;
pub type nvmlValueType_enum = raw::c_uint;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: raw::c_uint,
    pub ulVal: raw::c_ulong,
    pub ullVal: raw::c_ulonglong,
    pub sllVal: raw::c_longlong,
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    pub timeStamp: raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
pub type nvmlSample_t = nvmlSample_st;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = 0;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = 1;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = 2;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = 3;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum = 4;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = 5;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum = 10;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum = 11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = 12;
pub type nvmlPerfPolicyType_enum = raw::c_uint;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlViolationTime_st {
    pub referenceTime: raw::c_ulonglong,
    pub violationTime: raw::c_ulonglong,
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum = 0;
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
pub type nvmlEnableState_enum = raw::c_uint;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN: nvmlBrandType_enum = 6;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 7;
pub type nvmlBrandType_enum = raw::c_uint;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
    nvmlTemperatureThresholds_enum = 0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
    nvmlTemperatureThresholds_enum = 1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
    nvmlTemperatureThresholds_enum = 2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
    nvmlTemperatureThresholds_enum = 3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
    nvmlTemperatureThresholds_enum = 4;
pub type nvmlTemperatureThresholds_enum = raw::c_uint;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = 0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = 1;
pub type nvmlTemperatureSensors_enum = raw::c_uint;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = 0;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = 1;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = 2;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = 3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = 4;
pub type nvmlComputeMode_enum = raw::c_uint;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum = 0;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum = 1;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = 2;
pub type nvmlMemoryErrorType_enum = raw::c_uint;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum = 0;
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = 1;
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = 2;
pub type nvmlEccCounterType_enum = raw::c_uint;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
pub type nvmlClockType_enum = raw::c_uint;
pub use self::nvmlClockType_enum as nvmlClockType_t;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = 1;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = 2;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = 3;
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
pub type nvmlClockId_enum = raw::c_uint;
pub use self::nvmlClockId_enum as nvmlClockId_t;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
pub type nvmlDriverModel_enum = raw::c_uint;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
pub type nvmlPStates_enum = raw::c_uint;
pub use self::nvmlPStates_enum as nvmlPstates_t;
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
pub type nvmlGom_enum = raw::c_uint;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum = 2;
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum = 3;
pub type nvmlInforomObject_enum = raw::c_uint;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = 18;
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = 22;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = 23;
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
pub type nvmlReturn_enum = raw::c_uint;
pub use self::nvmlReturn_enum as nvmlReturn_t;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = 0;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = 1;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum = 3;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum = 4;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum = 5;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = 6;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = 7;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = 8;
pub type nvmlMemoryLocation_enum = raw::c_uint;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
    nvmlPageRetirementCause_enum = 0;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
    nvmlPageRetirementCause_enum = 1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
    nvmlPageRetirementCause_enum = 2;
pub type nvmlPageRetirementCause_enum = raw::c_uint;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
    nvmlRestrictedAPI_enum = 0;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
    nvmlRestrictedAPI_enum = 1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = 2;
pub type nvmlRestrictedAPI_enum = raw::c_uint;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
    0;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    nvmlGpuVirtualizationMode = 1;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
    2;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    nvmlGpuVirtualizationMode = 3;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    nvmlGpuVirtualizationMode = 4;
pub type nvmlGpuVirtualizationMode = raw::c_uint;
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = 0;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = 1;
pub type nvmlHostVgpuMode_enum = raw::c_uint;
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
pub type nvmlVgpuVmIdType = raw::c_uint;
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
    nvmlVgpuGuestInfoState_enum = 0;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
    nvmlVgpuGuestInfoState_enum = 1;
pub type nvmlVgpuGuestInfoState_enum = raw::c_uint;
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
    nvmlGridLicenseFeatureCode_t = 1;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
    nvmlGridLicenseFeatureCode_t = 2;
pub type nvmlGridLicenseFeatureCode_t = raw::c_uint;
pub type nvmlVgpuTypeId_t = raw::c_uint;
pub type nvmlVgpuInstance_t = raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: raw::c_uint,
    pub processName: [raw::c_char; 64usize],
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: raw::c_uint,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: raw::c_uint,
    pub licenseInfo: [raw::c_char; 128usize],
    pub productName: [raw::c_char; 128usize],
    pub featureEnabled: raw::c_uint,
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: raw::c_int,
    pub licensableFeaturesCount: raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    pub fieldId: raw::c_uint,
    pub scopeId: raw::c_uint,
    pub timestamp: raw::c_longlong,
    pub latencyUsec: raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: raw::c_uint,
    pub firmwareVersion: [raw::c_char; 32usize],
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
pub type nvmlFanState_enum = raw::c_uint;
pub use self::nvmlFanState_enum as nvmlFanState_t;
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
pub type nvmlLedColor_enum = raw::c_uint;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlLedState_st {
    pub cause: [raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitInfo_st {
    pub name: [raw::c_char; 96usize],
    pub id: [raw::c_char; 96usize],
    pub serial: [raw::c_char; 96usize],
    pub firmwareVersion: [raw::c_char; 96usize],
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPSUInfo_st {
    pub state: [raw::c_char; 256usize],
    pub current: raw::c_uint,
    pub voltage: raw::c_uint,
    pub power: raw::c_uint,
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    pub speed: raw::c_uint,
    pub state: nvmlFanState_t,
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: raw::c_uint,
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: raw::c_ulonglong,
    pub eventData: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: raw::c_uint,
    pub memoryUtilization: raw::c_uint,
    pub maxMemoryUsage: raw::c_ulonglong,
    pub time: raw::c_ulonglong,
    pub startTime: raw::c_ulonglong,
    pub isRunning: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = 0;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = 1;
pub type nvmlEncoderQueryType_enum = raw::c_uint;
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFps: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = 0;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = 1;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = 2;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = 3;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = 4;
pub type nvmlFBCSessionType_enum = raw::c_uint;
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCStats_st {
    pub sessionsCount: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub displayOrdinal: raw::c_uint,
    pub sessionType: nvmlFBCSessionType_t,
    pub sessionFlags: raw::c_uint,
    pub hMaxResolution: raw::c_uint,
    pub vMaxResolution: raw::c_uint,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = 0;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = 1;
pub type nvmlDetachGpuState_enum = raw::c_uint;
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = 0;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = 1;
pub type nvmlPcieLinkState_enum = raw::c_uint;
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
pub type nvmlAffinityScope_t = raw::c_uint;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_RANGE_START: nvmlClockLimitId_enum = 4294967040;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_TDP: nvmlClockLimitId_enum = 4294967041;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_UNLIMITED: nvmlClockLimitId_enum = 4294967042;
pub type nvmlClockLimitId_enum = raw::c_uint;
pub use self::nvmlClockLimitId_enum as nvmlClockLimitId_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    pub minVersion: raw::c_uint,
    pub maxVersion: raw::c_uint,
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    pub guestDriverVersion: [raw::c_char; 80usize],
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub reserved: [raw::c_uint; 6usize],
    pub vgpuVirtualizationCaps: raw::c_uint,
    pub guestVgpuVersion: raw::c_uint,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub pgpuVirtualizationCaps: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_NONE:
    nvmlVgpuVmCompatibility_enum = 0;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_COLD:
    nvmlVgpuVmCompatibility_enum = 1;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_HIBERNATE:
    nvmlVgpuVmCompatibility_enum = 2;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_SLEEP:
    nvmlVgpuVmCompatibility_enum = 4;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_LIVE:
    nvmlVgpuVmCompatibility_enum = 8;
pub type nvmlVgpuVmCompatibility_enum = raw::c_uint;
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_NONE:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 0;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 1;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GPU:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 4;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_OTHER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2147483648;
pub type nvmlVgpuPgpuCompatibilityLimitCode_enum = raw::c_uint;
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBlacklistDeviceInfo_st {
    pub pciInfo: nvmlPciInfo_t,
    pub uuid: [raw::c_char; 80usize],
}
pub type nvmlBlacklistDeviceInfo_t = nvmlBlacklistDeviceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstancePlacement_st {
    pub start: raw::c_uint,
    pub size: raw::c_uint,
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub isP2pSupported: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub copyEngineCount: raw::c_uint,
    pub decoderCount: raw::c_uint,
    pub encoderCount: raw::c_uint,
    pub jpegCount: raw::c_uint,
    pub ofaCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
}
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
    pub placement: nvmlGpuInstancePlacement_t,
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
}
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub gpuInstance: nvmlGpuInstance_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;
extern crate libloading;
pub struct NvmlLib {
    pub __library: ::libloading::Library,
    pub nvmlInit_v2: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlInitWithFlags:
        Result<unsafe extern "C" fn(flags: raw::c_uint) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlShutdown: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlErrorString: Result<
        unsafe extern "C" fn(result: nvmlReturn_t) -> *const raw::c_char,
        ::libloading::Error,
    >,
    pub nvmlSystemGetDriverVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetNVMLVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion_v2: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetProcessName: Result<
        unsafe extern "C" fn(
            pid: raw::c_uint,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetCount: Result<
        unsafe extern "C" fn(unitCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetHandleByIndex: Result<
        unsafe extern "C" fn(index: raw::c_uint, unit: *mut nvmlUnit_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetUnitInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, state: *mut nvmlLedState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetPsuInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetTemperature: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            type_: raw::c_uint,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetFanSpeedInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, fanSpeeds: *mut nvmlUnitFanSpeeds_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetDevices: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            deviceCount: *mut raw::c_uint,
            devices: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetHicVersion: Result<
        unsafe extern "C" fn(
            hwbcCount: *mut raw::c_uint,
            hwbcEntries: *mut nvmlHwbcEntry_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCount_v2: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAttributes: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            attributes: *mut nvmlDeviceAttributes_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByIndex_v2: Result<
        unsafe extern "C" fn(index: raw::c_uint, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleBySerial: Result<
        unsafe extern "C" fn(serial: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByUUID: Result<
        unsafe extern "C" fn(uuid: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByPciBusId_v2: Result<
        unsafe extern "C" fn(
            pciBusId: *const raw::c_char,
            device: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetName: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBrand: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, type_: *mut nvmlBrandType_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetIndex: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, index: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSerial: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            serial: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            nodeSetSize: raw::c_uint,
            nodeSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinityWithinScope: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceClearCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetTopologyCommonAncestor: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            pathInfo: *mut nvmlGpuTopologyLevel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTopologyNearestGpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            level: nvmlGpuTopologyLevel_t,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetTopologyGpuSet: Result<
        unsafe extern "C" fn(
            cpuNumber: raw::c_uint,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetP2PStatus: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            p2pIndex: nvmlGpuP2PCapsIndex_t,
            p2pStatus: *mut nvmlGpuP2PStatus_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUUID: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            uuid: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMdevUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mdevUuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMinorNumber: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, minorNumber: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardPartNumber: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            partNumber: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            object: nvmlInforomObject_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomImageVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomConfigurationChecksum: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, checksum: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceValidateInforom:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetDisplayMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, display: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDisplayActive: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPciInfo_v3: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieThroughput: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counter: nvmlPcieUtilCounter_t,
            value: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieReplayCounter: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, value: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDefaultApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetApplicationsClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockId: nvmlClockId_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxCustomerBoostClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedMemoryClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedGraphicsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memoryClockMHz: raw::c_uint,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isEnabled: *mut nvmlEnableState_t,
            defaultIsEnabled: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, enabled: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDefaultAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            enabled: nvmlEnableState_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, speed: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            speed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperature: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sensorType: nvmlTemperatureSensors_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperatureThreshold: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            thresholdType: nvmlTemperatureThresholds_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPerformanceState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrentClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            supportedClocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimitConstraints: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minLimit: *mut raw::c_uint,
            maxLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementDefaultLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, defaultLimit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerUsage: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, power: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEnergyConsumption: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, energy: *mut raw::c_ulonglong) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEnforcedPowerLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuOperationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlGpuOperationMode_t,
            pending: *mut nvmlGpuOperationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryInfo: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, memory: *mut nvmlMemory_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCudaComputeCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            major: *mut raw::c_int,
            minor: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEccMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlEnableState_t,
            pending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, boardId: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMultiGpuBoard: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, multiGpuBool: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDetailedEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut nvmlEccErrorCounts_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            locationType: nvmlMemoryLocation_t,
            count: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUtilizationRates: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlUtilization_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            encoderQueryType: nvmlEncoderType_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfos: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDecoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCStats: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, fbcStats: *mut nvmlFBCStats_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlDriverModel_t,
            pending: *mut nvmlDriverModel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVbiosVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBridgeChipInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeRunningProcesses: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGraphicsRunningProcesses: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceOnSameBoard: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            onSameBoard: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSamples: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlSamplingType_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            sampleCount: *mut raw::c_uint,
            samples: *mut nvmlSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBAR1MemoryInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bar1Memory: *mut nvmlBAR1Memory_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetViolationStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            perfPolicyType: nvmlPerfPolicyType_t,
            violTime: *mut nvmlViolationTime_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingPids: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingBufferSize: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, bufferSize: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
            timestamps: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPagesPendingStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isPending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRemappedRows: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            corrRows: *mut raw::c_uint,
            uncRows: *mut raw::c_uint,
            isPending: *mut raw::c_uint,
            failureOccurred: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetArchitecture: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            arch: *mut nvmlDeviceArchitecture_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitSetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetEccMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, ecc: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearEccErrorCounts: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counterType: nvmlEccCounterType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            driverModel: nvmlDriverModel_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuLockedClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minGpuClockMHz: raw::c_uint,
            maxGpuClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetGpuLockedClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceSetApplicationsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memClockMHz: raw::c_uint,
            graphicsClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuOperationMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlGpuOperationMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearAccountingPids:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetNvLinkState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            version: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            capability: nvmlNvLinkCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkRemotePciInfo_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            pci: *mut nvmlPciInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: nvmlNvLinkErrorCounter_t,
            counterValue: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkErrorCounters: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, link: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
            reset: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            rxcounter: *mut raw::c_ulonglong,
            txcounter: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceFreezeNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            freeze: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetCreate:
        Result<unsafe extern "C" fn(set: *mut nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceRegisterEvents: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: raw::c_ulonglong,
            set: nvmlEventSet_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedEventTypes: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetWait_v2: Result<
        unsafe extern "C" fn(
            set: nvmlEventSet_t,
            data: *mut nvmlEventData_t,
            timeoutms: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetFree:
        Result<unsafe extern "C" fn(set: nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceModifyDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            newState: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceQueryDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            currentState: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceRemoveGpu_v2: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            gpuState: nvmlDetachGpuState_t,
            linkState: nvmlPcieLinkState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceDiscoverGpus: Result<
        unsafe extern "C" fn(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFieldValues: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            valuesCount: raw::c_int,
            values: *mut nvmlFieldValue_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHostVgpuMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pHostVgpuMode: *mut nvmlHostVgpuMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            virtualMode: nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGridLicensableFeatures_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlProcessUtilizationSample_t,
            processSamplesCount: *mut raw::c_uint,
            lastSeenTimeStamp: raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCreatableVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetClass: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeClass: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetName: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeName: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetDeviceID: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            deviceID: *mut raw::c_ulonglong,
            subsystemID: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFramebufferSize: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            fbSize: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetNumDisplayHeads: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            numDisplayHeads: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetResolution: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            displayIndex: raw::c_uint,
            xdim: *mut raw::c_uint,
            ydim: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetLicense: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeLicenseString: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCount: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstancesPerVm: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCountPerVm: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetActiveVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuInstances: *mut nvmlVgpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vmId: *mut raw::c_char,
            size: raw::c_uint,
            vmIdType: *mut nvmlVgpuVmIdType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            uuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmDriverVersion: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFbUsage: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbUsage: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetLicenseStatus: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            licensed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetType: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuTypeId: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEccMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            eccMode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceSetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbcStats: *mut nvmlFBCStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMetadata: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuMetadata: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuCompatibility: Result<
        unsafe extern "C" fn(
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPgpuMetadataString: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut raw::c_char,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuVersion: Result<
        unsafe extern "C" fn(
            supported: *mut nvmlVgpuVersion_t,
            current: *mut nvmlVgpuVersion_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSetVgpuVersion: Result<
        unsafe extern "C" fn(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            vgpuInstanceSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            vgpuProcessSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingPids: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceClearAccountingPids: Result<
        unsafe extern "C" fn(vgpuInstance: nvmlVgpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetBlacklistDeviceCount: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetBlacklistDeviceInfoByIndex: Result<
        unsafe extern "C" fn(
            index: raw::c_uint,
            info: *mut nvmlBlacklistDeviceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            mode: raw::c_uint,
            activationStatus: *mut nvmlReturn_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            currentMode: *mut raw::c_uint,
            pendingMode: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profile: raw::c_uint,
            info: *mut nvmlGpuInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstancePossiblePlacements: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            placements: *mut nvmlGpuInstancePlacement_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceCreateGpuInstance: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceDestroy: Result<
        unsafe extern "C" fn(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstances: *mut nvmlGpuInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceById: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            id: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            info: *mut nvmlGpuInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profile: raw::c_uint,
            engProfile: raw::c_uint,
            info: *mut nvmlComputeInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceCreateComputeInstance: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceDestroy: Result<
        unsafe extern "C" fn(computeInstance: nvmlComputeInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstances: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstances: *mut nvmlComputeInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceById: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            id: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceGetInfo: Result<
        unsafe extern "C" fn(
            computeInstance: nvmlComputeInstance_t,
            info: *mut nvmlComputeInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceIsMigDeviceHandle: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, isMigDevice: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxMigDeviceCount: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, count: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigDeviceHandleByIndex: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            index: raw::c_uint,
            migDevice: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDeviceHandleFromMigDeviceHandle: Result<
        unsafe extern "C" fn(migDevice: nvmlDevice_t, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
}
impl NvmlLib {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let nvmlInit_v2 = __library.get(b"nvmlInit_v2\0").map(|sym| *sym);
        let nvmlInitWithFlags = __library.get(b"nvmlInitWithFlags\0").map(|sym| *sym);
        let nvmlShutdown = __library.get(b"nvmlShutdown\0").map(|sym| *sym);
        let nvmlErrorString = __library.get(b"nvmlErrorString\0").map(|sym| *sym);
        let nvmlSystemGetDriverVersion = __library
            .get(b"nvmlSystemGetDriverVersion\0")
            .map(|sym| *sym);
        let nvmlSystemGetNVMLVersion = __library.get(b"nvmlSystemGetNVMLVersion\0").map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion = __library
            .get(b"nvmlSystemGetCudaDriverVersion\0")
            .map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion_v2 = __library
            .get(b"nvmlSystemGetCudaDriverVersion_v2\0")
            .map(|sym| *sym);
        let nvmlSystemGetProcessName = __library.get(b"nvmlSystemGetProcessName\0").map(|sym| *sym);
        let nvmlUnitGetCount = __library.get(b"nvmlUnitGetCount\0").map(|sym| *sym);
        let nvmlUnitGetHandleByIndex = __library.get(b"nvmlUnitGetHandleByIndex\0").map(|sym| *sym);
        let nvmlUnitGetUnitInfo = __library.get(b"nvmlUnitGetUnitInfo\0").map(|sym| *sym);
        let nvmlUnitGetLedState = __library.get(b"nvmlUnitGetLedState\0").map(|sym| *sym);
        let nvmlUnitGetPsuInfo = __library.get(b"nvmlUnitGetPsuInfo\0").map(|sym| *sym);
        let nvmlUnitGetTemperature = __library.get(b"nvmlUnitGetTemperature\0").map(|sym| *sym);
        let nvmlUnitGetFanSpeedInfo = __library.get(b"nvmlUnitGetFanSpeedInfo\0").map(|sym| *sym);
        let nvmlUnitGetDevices = __library.get(b"nvmlUnitGetDevices\0").map(|sym| *sym);
        let nvmlSystemGetHicVersion = __library.get(b"nvmlSystemGetHicVersion\0").map(|sym| *sym);
        let nvmlDeviceGetCount_v2 = __library.get(b"nvmlDeviceGetCount_v2\0").map(|sym| *sym);
        let nvmlDeviceGetAttributes = __library.get(b"nvmlDeviceGetAttributes\0").map(|sym| *sym);
        let nvmlDeviceGetHandleByIndex_v2 = __library
            .get(b"nvmlDeviceGetHandleByIndex_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleBySerial = __library
            .get(b"nvmlDeviceGetHandleBySerial\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByUUID = __library
            .get(b"nvmlDeviceGetHandleByUUID\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByPciBusId_v2 = __library
            .get(b"nvmlDeviceGetHandleByPciBusId_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetName = __library.get(b"nvmlDeviceGetName\0").map(|sym| *sym);
        let nvmlDeviceGetBrand = __library.get(b"nvmlDeviceGetBrand\0").map(|sym| *sym);
        let nvmlDeviceGetIndex = __library.get(b"nvmlDeviceGetIndex\0").map(|sym| *sym);
        let nvmlDeviceGetSerial = __library.get(b"nvmlDeviceGetSerial\0").map(|sym| *sym);
        let nvmlDeviceGetMemoryAffinity = __library
            .get(b"nvmlDeviceGetMemoryAffinity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinityWithinScope = __library
            .get(b"nvmlDeviceGetCpuAffinityWithinScope\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinity = __library.get(b"nvmlDeviceGetCpuAffinity\0").map(|sym| *sym);
        let nvmlDeviceSetCpuAffinity = __library.get(b"nvmlDeviceSetCpuAffinity\0").map(|sym| *sym);
        let nvmlDeviceClearCpuAffinity = __library
            .get(b"nvmlDeviceClearCpuAffinity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyCommonAncestor = __library
            .get(b"nvmlDeviceGetTopologyCommonAncestor\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyNearestGpus = __library
            .get(b"nvmlDeviceGetTopologyNearestGpus\0")
            .map(|sym| *sym);
        let nvmlSystemGetTopologyGpuSet = __library
            .get(b"nvmlSystemGetTopologyGpuSet\0")
            .map(|sym| *sym);
        let nvmlDeviceGetP2PStatus = __library.get(b"nvmlDeviceGetP2PStatus\0").map(|sym| *sym);
        let nvmlDeviceGetUUID = __library.get(b"nvmlDeviceGetUUID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetMdevUUID = __library
            .get(b"nvmlVgpuInstanceGetMdevUUID\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMinorNumber = __library.get(b"nvmlDeviceGetMinorNumber\0").map(|sym| *sym);
        let nvmlDeviceGetBoardPartNumber = __library
            .get(b"nvmlDeviceGetBoardPartNumber\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomVersion = __library
            .get(b"nvmlDeviceGetInforomVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomImageVersion = __library
            .get(b"nvmlDeviceGetInforomImageVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomConfigurationChecksum = __library
            .get(b"nvmlDeviceGetInforomConfigurationChecksum\0")
            .map(|sym| *sym);
        let nvmlDeviceValidateInforom = __library
            .get(b"nvmlDeviceValidateInforom\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDisplayMode = __library.get(b"nvmlDeviceGetDisplayMode\0").map(|sym| *sym);
        let nvmlDeviceGetDisplayActive = __library
            .get(b"nvmlDeviceGetDisplayActive\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPersistenceMode = __library
            .get(b"nvmlDeviceGetPersistenceMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPciInfo_v3 = __library.get(b"nvmlDeviceGetPciInfo_v3\0").map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkGeneration = __library
            .get(b"nvmlDeviceGetMaxPcieLinkGeneration\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkWidth = __library
            .get(b"nvmlDeviceGetMaxPcieLinkWidth\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkGeneration = __library
            .get(b"nvmlDeviceGetCurrPcieLinkGeneration\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkWidth = __library
            .get(b"nvmlDeviceGetCurrPcieLinkWidth\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieThroughput = __library
            .get(b"nvmlDeviceGetPcieThroughput\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieReplayCounter = __library
            .get(b"nvmlDeviceGetPcieReplayCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceGetClockInfo = __library.get(b"nvmlDeviceGetClockInfo\0").map(|sym| *sym);
        let nvmlDeviceGetMaxClockInfo = __library
            .get(b"nvmlDeviceGetMaxClockInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetApplicationsClock = __library
            .get(b"nvmlDeviceGetApplicationsClock\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDefaultApplicationsClock = __library
            .get(b"nvmlDeviceGetDefaultApplicationsClock\0")
            .map(|sym| *sym);
        let nvmlDeviceResetApplicationsClocks = __library
            .get(b"nvmlDeviceResetApplicationsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetClock = __library.get(b"nvmlDeviceGetClock\0").map(|sym| *sym);
        let nvmlDeviceGetMaxCustomerBoostClock = __library
            .get(b"nvmlDeviceGetMaxCustomerBoostClock\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedMemoryClocks = __library
            .get(b"nvmlDeviceGetSupportedMemoryClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedGraphicsClocks = __library
            .get(b"nvmlDeviceGetSupportedGraphicsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceGetAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceSetAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceSetDefaultAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceSetDefaultAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceGetFanSpeed = __library.get(b"nvmlDeviceGetFanSpeed\0").map(|sym| *sym);
        let nvmlDeviceGetFanSpeed_v2 = __library.get(b"nvmlDeviceGetFanSpeed_v2\0").map(|sym| *sym);
        let nvmlDeviceGetTemperature = __library.get(b"nvmlDeviceGetTemperature\0").map(|sym| *sym);
        let nvmlDeviceGetTemperatureThreshold = __library
            .get(b"nvmlDeviceGetTemperatureThreshold\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPerformanceState = __library
            .get(b"nvmlDeviceGetPerformanceState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrentClocksThrottleReasons = __library
            .get(b"nvmlDeviceGetCurrentClocksThrottleReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedClocksThrottleReasons = __library
            .get(b"nvmlDeviceGetSupportedClocksThrottleReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerState = __library.get(b"nvmlDeviceGetPowerState\0").map(|sym| *sym);
        let nvmlDeviceGetPowerManagementMode = __library
            .get(b"nvmlDeviceGetPowerManagementMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimit = __library
            .get(b"nvmlDeviceGetPowerManagementLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimitConstraints = __library
            .get(b"nvmlDeviceGetPowerManagementLimitConstraints\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementDefaultLimit = __library
            .get(b"nvmlDeviceGetPowerManagementDefaultLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerUsage = __library.get(b"nvmlDeviceGetPowerUsage\0").map(|sym| *sym);
        let nvmlDeviceGetTotalEnergyConsumption = __library
            .get(b"nvmlDeviceGetTotalEnergyConsumption\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEnforcedPowerLimit = __library
            .get(b"nvmlDeviceGetEnforcedPowerLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuOperationMode = __library
            .get(b"nvmlDeviceGetGpuOperationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryInfo = __library.get(b"nvmlDeviceGetMemoryInfo\0").map(|sym| *sym);
        let nvmlDeviceGetComputeMode = __library.get(b"nvmlDeviceGetComputeMode\0").map(|sym| *sym);
        let nvmlDeviceGetCudaComputeCapability = __library
            .get(b"nvmlDeviceGetCudaComputeCapability\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEccMode = __library.get(b"nvmlDeviceGetEccMode\0").map(|sym| *sym);
        let nvmlDeviceGetBoardId = __library.get(b"nvmlDeviceGetBoardId\0").map(|sym| *sym);
        let nvmlDeviceGetMultiGpuBoard = __library
            .get(b"nvmlDeviceGetMultiGpuBoard\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTotalEccErrors = __library
            .get(b"nvmlDeviceGetTotalEccErrors\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDetailedEccErrors = __library
            .get(b"nvmlDeviceGetDetailedEccErrors\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryErrorCounter = __library
            .get(b"nvmlDeviceGetMemoryErrorCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceGetUtilizationRates = __library
            .get(b"nvmlDeviceGetUtilizationRates\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderUtilization = __library
            .get(b"nvmlDeviceGetEncoderUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderCapacity = __library
            .get(b"nvmlDeviceGetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderStats = __library
            .get(b"nvmlDeviceGetEncoderStats\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderSessions = __library
            .get(b"nvmlDeviceGetEncoderSessions\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDecoderUtilization = __library
            .get(b"nvmlDeviceGetDecoderUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetFBCStats = __library.get(b"nvmlDeviceGetFBCStats\0").map(|sym| *sym);
        let nvmlDeviceGetFBCSessions = __library.get(b"nvmlDeviceGetFBCSessions\0").map(|sym| *sym);
        let nvmlDeviceGetDriverModel = __library.get(b"nvmlDeviceGetDriverModel\0").map(|sym| *sym);
        let nvmlDeviceGetVbiosVersion = __library
            .get(b"nvmlDeviceGetVbiosVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetBridgeChipInfo = __library
            .get(b"nvmlDeviceGetBridgeChipInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetComputeRunningProcesses = __library
            .get(b"nvmlDeviceGetComputeRunningProcesses\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGraphicsRunningProcesses = __library
            .get(b"nvmlDeviceGetGraphicsRunningProcesses\0")
            .map(|sym| *sym);
        let nvmlDeviceOnSameBoard = __library.get(b"nvmlDeviceOnSameBoard\0").map(|sym| *sym);
        let nvmlDeviceGetAPIRestriction = __library
            .get(b"nvmlDeviceGetAPIRestriction\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSamples = __library.get(b"nvmlDeviceGetSamples\0").map(|sym| *sym);
        let nvmlDeviceGetBAR1MemoryInfo = __library
            .get(b"nvmlDeviceGetBAR1MemoryInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetViolationStatus = __library
            .get(b"nvmlDeviceGetViolationStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingMode = __library
            .get(b"nvmlDeviceGetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingStats = __library
            .get(b"nvmlDeviceGetAccountingStats\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingPids = __library
            .get(b"nvmlDeviceGetAccountingPids\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingBufferSize = __library
            .get(b"nvmlDeviceGetAccountingBufferSize\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages = __library
            .get(b"nvmlDeviceGetRetiredPages\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages_v2 = __library
            .get(b"nvmlDeviceGetRetiredPages_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPagesPendingStatus = __library
            .get(b"nvmlDeviceGetRetiredPagesPendingStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRemappedRows = __library
            .get(b"nvmlDeviceGetRemappedRows\0")
            .map(|sym| *sym);
        let nvmlDeviceGetArchitecture = __library
            .get(b"nvmlDeviceGetArchitecture\0")
            .map(|sym| *sym);
        let nvmlUnitSetLedState = __library.get(b"nvmlUnitSetLedState\0").map(|sym| *sym);
        let nvmlDeviceSetPersistenceMode = __library
            .get(b"nvmlDeviceSetPersistenceMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetComputeMode = __library.get(b"nvmlDeviceSetComputeMode\0").map(|sym| *sym);
        let nvmlDeviceSetEccMode = __library.get(b"nvmlDeviceSetEccMode\0").map(|sym| *sym);
        let nvmlDeviceClearEccErrorCounts = __library
            .get(b"nvmlDeviceClearEccErrorCounts\0")
            .map(|sym| *sym);
        let nvmlDeviceSetDriverModel = __library.get(b"nvmlDeviceSetDriverModel\0").map(|sym| *sym);
        let nvmlDeviceSetGpuLockedClocks = __library
            .get(b"nvmlDeviceSetGpuLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceResetGpuLockedClocks = __library
            .get(b"nvmlDeviceResetGpuLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceSetApplicationsClocks = __library
            .get(b"nvmlDeviceSetApplicationsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceSetPowerManagementLimit = __library
            .get(b"nvmlDeviceSetPowerManagementLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceSetGpuOperationMode = __library
            .get(b"nvmlDeviceSetGpuOperationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAPIRestriction = __library
            .get(b"nvmlDeviceSetAPIRestriction\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAccountingMode = __library
            .get(b"nvmlDeviceSetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlDeviceClearAccountingPids = __library
            .get(b"nvmlDeviceClearAccountingPids\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkState = __library.get(b"nvmlDeviceGetNvLinkState\0").map(|sym| *sym);
        let nvmlDeviceGetNvLinkVersion = __library
            .get(b"nvmlDeviceGetNvLinkVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkCapability = __library
            .get(b"nvmlDeviceGetNvLinkCapability\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkRemotePciInfo_v2 = __library
            .get(b"nvmlDeviceGetNvLinkRemotePciInfo_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkErrorCounter = __library
            .get(b"nvmlDeviceGetNvLinkErrorCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkErrorCounters = __library
            .get(b"nvmlDeviceResetNvLinkErrorCounters\0")
            .map(|sym| *sym);
        let nvmlDeviceSetNvLinkUtilizationControl = __library
            .get(b"nvmlDeviceSetNvLinkUtilizationControl\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationControl = __library
            .get(b"nvmlDeviceGetNvLinkUtilizationControl\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceGetNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceFreezeNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceFreezeNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceResetNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlEventSetCreate = __library.get(b"nvmlEventSetCreate\0").map(|sym| *sym);
        let nvmlDeviceRegisterEvents = __library.get(b"nvmlDeviceRegisterEvents\0").map(|sym| *sym);
        let nvmlDeviceGetSupportedEventTypes = __library
            .get(b"nvmlDeviceGetSupportedEventTypes\0")
            .map(|sym| *sym);
        let nvmlEventSetWait_v2 = __library.get(b"nvmlEventSetWait_v2\0").map(|sym| *sym);
        let nvmlEventSetFree = __library.get(b"nvmlEventSetFree\0").map(|sym| *sym);
        let nvmlDeviceModifyDrainState = __library
            .get(b"nvmlDeviceModifyDrainState\0")
            .map(|sym| *sym);
        let nvmlDeviceQueryDrainState = __library
            .get(b"nvmlDeviceQueryDrainState\0")
            .map(|sym| *sym);
        let nvmlDeviceRemoveGpu_v2 = __library.get(b"nvmlDeviceRemoveGpu_v2\0").map(|sym| *sym);
        let nvmlDeviceDiscoverGpus = __library.get(b"nvmlDeviceDiscoverGpus\0").map(|sym| *sym);
        let nvmlDeviceGetFieldValues = __library.get(b"nvmlDeviceGetFieldValues\0").map(|sym| *sym);
        let nvmlDeviceGetVirtualizationMode = __library
            .get(b"nvmlDeviceGetVirtualizationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHostVgpuMode = __library
            .get(b"nvmlDeviceGetHostVgpuMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetVirtualizationMode = __library
            .get(b"nvmlDeviceSetVirtualizationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGridLicensableFeatures_v3 = __library
            .get(b"nvmlDeviceGetGridLicensableFeatures_v3\0")
            .map(|sym| *sym);
        let nvmlDeviceGetProcessUtilization = __library
            .get(b"nvmlDeviceGetProcessUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedVgpus = __library
            .get(b"nvmlDeviceGetSupportedVgpus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCreatableVgpus = __library
            .get(b"nvmlDeviceGetCreatableVgpus\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetClass = __library.get(b"nvmlVgpuTypeGetClass\0").map(|sym| *sym);
        let nvmlVgpuTypeGetName = __library.get(b"nvmlVgpuTypeGetName\0").map(|sym| *sym);
        let nvmlVgpuTypeGetDeviceID = __library.get(b"nvmlVgpuTypeGetDeviceID\0").map(|sym| *sym);
        let nvmlVgpuTypeGetFramebufferSize = __library
            .get(b"nvmlVgpuTypeGetFramebufferSize\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetNumDisplayHeads = __library
            .get(b"nvmlVgpuTypeGetNumDisplayHeads\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetResolution = __library
            .get(b"nvmlVgpuTypeGetResolution\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetLicense = __library.get(b"nvmlVgpuTypeGetLicense\0").map(|sym| *sym);
        let nvmlVgpuTypeGetFrameRateLimit = __library
            .get(b"nvmlVgpuTypeGetFrameRateLimit\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstances = __library
            .get(b"nvmlVgpuTypeGetMaxInstances\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstancesPerVm = __library
            .get(b"nvmlVgpuTypeGetMaxInstancesPerVm\0")
            .map(|sym| *sym);
        let nvmlDeviceGetActiveVgpus = __library.get(b"nvmlDeviceGetActiveVgpus\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetVmID = __library.get(b"nvmlVgpuInstanceGetVmID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetUUID = __library.get(b"nvmlVgpuInstanceGetUUID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetVmDriverVersion = __library
            .get(b"nvmlVgpuInstanceGetVmDriverVersion\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFbUsage = __library
            .get(b"nvmlVgpuInstanceGetFbUsage\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetLicenseStatus = __library
            .get(b"nvmlVgpuInstanceGetLicenseStatus\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetType = __library.get(b"nvmlVgpuInstanceGetType\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetFrameRateLimit = __library
            .get(b"nvmlVgpuInstanceGetFrameRateLimit\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEccMode = __library
            .get(b"nvmlVgpuInstanceGetEccMode\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderCapacity = __library
            .get(b"nvmlVgpuInstanceGetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceSetEncoderCapacity = __library
            .get(b"nvmlVgpuInstanceSetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderStats = __library
            .get(b"nvmlVgpuInstanceGetEncoderStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderSessions = __library
            .get(b"nvmlVgpuInstanceGetEncoderSessions\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCStats = __library
            .get(b"nvmlVgpuInstanceGetFBCStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCSessions = __library
            .get(b"nvmlVgpuInstanceGetFBCSessions\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetMetadata = __library
            .get(b"nvmlVgpuInstanceGetMetadata\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuMetadata = __library
            .get(b"nvmlDeviceGetVgpuMetadata\0")
            .map(|sym| *sym);
        let nvmlGetVgpuCompatibility = __library.get(b"nvmlGetVgpuCompatibility\0").map(|sym| *sym);
        let nvmlDeviceGetPgpuMetadataString = __library
            .get(b"nvmlDeviceGetPgpuMetadataString\0")
            .map(|sym| *sym);
        let nvmlGetVgpuVersion = __library.get(b"nvmlGetVgpuVersion\0").map(|sym| *sym);
        let nvmlSetVgpuVersion = __library.get(b"nvmlSetVgpuVersion\0").map(|sym| *sym);
        let nvmlDeviceGetVgpuUtilization = __library
            .get(b"nvmlDeviceGetVgpuUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuProcessUtilization = __library
            .get(b"nvmlDeviceGetVgpuProcessUtilization\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingMode = __library
            .get(b"nvmlVgpuInstanceGetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingPids = __library
            .get(b"nvmlVgpuInstanceGetAccountingPids\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingStats = __library
            .get(b"nvmlVgpuInstanceGetAccountingStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceClearAccountingPids = __library
            .get(b"nvmlVgpuInstanceClearAccountingPids\0")
            .map(|sym| *sym);
        let nvmlGetBlacklistDeviceCount = __library
            .get(b"nvmlGetBlacklistDeviceCount\0")
            .map(|sym| *sym);
        let nvmlGetBlacklistDeviceInfoByIndex = __library
            .get(b"nvmlGetBlacklistDeviceInfoByIndex\0")
            .map(|sym| *sym);
        let nvmlDeviceSetMigMode = __library.get(b"nvmlDeviceSetMigMode\0").map(|sym| *sym);
        let nvmlDeviceGetMigMode = __library.get(b"nvmlDeviceGetMigMode\0").map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceProfileInfo = __library
            .get(b"nvmlDeviceGetGpuInstanceProfileInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstancePossiblePlacements = __library
            .get(b"nvmlDeviceGetGpuInstancePossiblePlacements\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceRemainingCapacity = __library
            .get(b"nvmlDeviceGetGpuInstanceRemainingCapacity\0")
            .map(|sym| *sym);
        let nvmlDeviceCreateGpuInstance = __library
            .get(b"nvmlDeviceCreateGpuInstance\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceDestroy = __library.get(b"nvmlGpuInstanceDestroy\0").map(|sym| *sym);
        let nvmlDeviceGetGpuInstances = __library
            .get(b"nvmlDeviceGetGpuInstances\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceById = __library
            .get(b"nvmlDeviceGetGpuInstanceById\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetInfo = __library.get(b"nvmlGpuInstanceGetInfo\0").map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceProfileInfo = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceProfileInfo\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceRemainingCapacity = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceRemainingCapacity\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceCreateComputeInstance = __library
            .get(b"nvmlGpuInstanceCreateComputeInstance\0")
            .map(|sym| *sym);
        let nvmlComputeInstanceDestroy = __library
            .get(b"nvmlComputeInstanceDestroy\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstances = __library
            .get(b"nvmlGpuInstanceGetComputeInstances\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceById = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceById\0")
            .map(|sym| *sym);
        let nvmlComputeInstanceGetInfo = __library
            .get(b"nvmlComputeInstanceGetInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceIsMigDeviceHandle = __library
            .get(b"nvmlDeviceIsMigDeviceHandle\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceId = __library
            .get(b"nvmlDeviceGetGpuInstanceId\0")
            .map(|sym| *sym);
        let nvmlDeviceGetComputeInstanceId = __library
            .get(b"nvmlDeviceGetComputeInstanceId\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMaxMigDeviceCount = __library
            .get(b"nvmlDeviceGetMaxMigDeviceCount\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMigDeviceHandleByIndex = __library
            .get(b"nvmlDeviceGetMigDeviceHandleByIndex\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDeviceHandleFromMigDeviceHandle = __library
            .get(b"nvmlDeviceGetDeviceHandleFromMigDeviceHandle\0")
            .map(|sym| *sym);
        Ok(NvmlLib {
            __library,
            nvmlInit_v2,
            nvmlInitWithFlags,
            nvmlShutdown,
            nvmlErrorString,
            nvmlSystemGetDriverVersion,
            nvmlSystemGetNVMLVersion,
            nvmlSystemGetCudaDriverVersion,
            nvmlSystemGetCudaDriverVersion_v2,
            nvmlSystemGetProcessName,
            nvmlUnitGetCount,
            nvmlUnitGetHandleByIndex,
            nvmlUnitGetUnitInfo,
            nvmlUnitGetLedState,
            nvmlUnitGetPsuInfo,
            nvmlUnitGetTemperature,
            nvmlUnitGetFanSpeedInfo,
            nvmlUnitGetDevices,
            nvmlSystemGetHicVersion,
            nvmlDeviceGetCount_v2,
            nvmlDeviceGetAttributes,
            nvmlDeviceGetHandleByIndex_v2,
            nvmlDeviceGetHandleBySerial,
            nvmlDeviceGetHandleByUUID,
            nvmlDeviceGetHandleByPciBusId_v2,
            nvmlDeviceGetName,
            nvmlDeviceGetBrand,
            nvmlDeviceGetIndex,
            nvmlDeviceGetSerial,
            nvmlDeviceGetMemoryAffinity,
            nvmlDeviceGetCpuAffinityWithinScope,
            nvmlDeviceGetCpuAffinity,
            nvmlDeviceSetCpuAffinity,
            nvmlDeviceClearCpuAffinity,
            nvmlDeviceGetTopologyCommonAncestor,
            nvmlDeviceGetTopologyNearestGpus,
            nvmlSystemGetTopologyGpuSet,
            nvmlDeviceGetP2PStatus,
            nvmlDeviceGetUUID,
            nvmlVgpuInstanceGetMdevUUID,
            nvmlDeviceGetMinorNumber,
            nvmlDeviceGetBoardPartNumber,
            nvmlDeviceGetInforomVersion,
            nvmlDeviceGetInforomImageVersion,
            nvmlDeviceGetInforomConfigurationChecksum,
            nvmlDeviceValidateInforom,
            nvmlDeviceGetDisplayMode,
            nvmlDeviceGetDisplayActive,
            nvmlDeviceGetPersistenceMode,
            nvmlDeviceGetPciInfo_v3,
            nvmlDeviceGetMaxPcieLinkGeneration,
            nvmlDeviceGetMaxPcieLinkWidth,
            nvmlDeviceGetCurrPcieLinkGeneration,
            nvmlDeviceGetCurrPcieLinkWidth,
            nvmlDeviceGetPcieThroughput,
            nvmlDeviceGetPcieReplayCounter,
            nvmlDeviceGetClockInfo,
            nvmlDeviceGetMaxClockInfo,
            nvmlDeviceGetApplicationsClock,
            nvmlDeviceGetDefaultApplicationsClock,
            nvmlDeviceResetApplicationsClocks,
            nvmlDeviceGetClock,
            nvmlDeviceGetMaxCustomerBoostClock,
            nvmlDeviceGetSupportedMemoryClocks,
            nvmlDeviceGetSupportedGraphicsClocks,
            nvmlDeviceGetAutoBoostedClocksEnabled,
            nvmlDeviceSetAutoBoostedClocksEnabled,
            nvmlDeviceSetDefaultAutoBoostedClocksEnabled,
            nvmlDeviceGetFanSpeed,
            nvmlDeviceGetFanSpeed_v2,
            nvmlDeviceGetTemperature,
            nvmlDeviceGetTemperatureThreshold,
            nvmlDeviceGetPerformanceState,
            nvmlDeviceGetCurrentClocksThrottleReasons,
            nvmlDeviceGetSupportedClocksThrottleReasons,
            nvmlDeviceGetPowerState,
            nvmlDeviceGetPowerManagementMode,
            nvmlDeviceGetPowerManagementLimit,
            nvmlDeviceGetPowerManagementLimitConstraints,
            nvmlDeviceGetPowerManagementDefaultLimit,
            nvmlDeviceGetPowerUsage,
            nvmlDeviceGetTotalEnergyConsumption,
            nvmlDeviceGetEnforcedPowerLimit,
            nvmlDeviceGetGpuOperationMode,
            nvmlDeviceGetMemoryInfo,
            nvmlDeviceGetComputeMode,
            nvmlDeviceGetCudaComputeCapability,
            nvmlDeviceGetEccMode,
            nvmlDeviceGetBoardId,
            nvmlDeviceGetMultiGpuBoard,
            nvmlDeviceGetTotalEccErrors,
            nvmlDeviceGetDetailedEccErrors,
            nvmlDeviceGetMemoryErrorCounter,
            nvmlDeviceGetUtilizationRates,
            nvmlDeviceGetEncoderUtilization,
            nvmlDeviceGetEncoderCapacity,
            nvmlDeviceGetEncoderStats,
            nvmlDeviceGetEncoderSessions,
            nvmlDeviceGetDecoderUtilization,
            nvmlDeviceGetFBCStats,
            nvmlDeviceGetFBCSessions,
            nvmlDeviceGetDriverModel,
            nvmlDeviceGetVbiosVersion,
            nvmlDeviceGetBridgeChipInfo,
            nvmlDeviceGetComputeRunningProcesses,
            nvmlDeviceGetGraphicsRunningProcesses,
            nvmlDeviceOnSameBoard,
            nvmlDeviceGetAPIRestriction,
            nvmlDeviceGetSamples,
            nvmlDeviceGetBAR1MemoryInfo,
            nvmlDeviceGetViolationStatus,
            nvmlDeviceGetAccountingMode,
            nvmlDeviceGetAccountingStats,
            nvmlDeviceGetAccountingPids,
            nvmlDeviceGetAccountingBufferSize,
            nvmlDeviceGetRetiredPages,
            nvmlDeviceGetRetiredPages_v2,
            nvmlDeviceGetRetiredPagesPendingStatus,
            nvmlDeviceGetRemappedRows,
            nvmlDeviceGetArchitecture,
            nvmlUnitSetLedState,
            nvmlDeviceSetPersistenceMode,
            nvmlDeviceSetComputeMode,
            nvmlDeviceSetEccMode,
            nvmlDeviceClearEccErrorCounts,
            nvmlDeviceSetDriverModel,
            nvmlDeviceSetGpuLockedClocks,
            nvmlDeviceResetGpuLockedClocks,
            nvmlDeviceSetApplicationsClocks,
            nvmlDeviceSetPowerManagementLimit,
            nvmlDeviceSetGpuOperationMode,
            nvmlDeviceSetAPIRestriction,
            nvmlDeviceSetAccountingMode,
            nvmlDeviceClearAccountingPids,
            nvmlDeviceGetNvLinkState,
            nvmlDeviceGetNvLinkVersion,
            nvmlDeviceGetNvLinkCapability,
            nvmlDeviceGetNvLinkRemotePciInfo_v2,
            nvmlDeviceGetNvLinkErrorCounter,
            nvmlDeviceResetNvLinkErrorCounters,
            nvmlDeviceSetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationCounter,
            nvmlDeviceFreezeNvLinkUtilizationCounter,
            nvmlDeviceResetNvLinkUtilizationCounter,
            nvmlEventSetCreate,
            nvmlDeviceRegisterEvents,
            nvmlDeviceGetSupportedEventTypes,
            nvmlEventSetWait_v2,
            nvmlEventSetFree,
            nvmlDeviceModifyDrainState,
            nvmlDeviceQueryDrainState,
            nvmlDeviceRemoveGpu_v2,
            nvmlDeviceDiscoverGpus,
            nvmlDeviceGetFieldValues,
            nvmlDeviceGetVirtualizationMode,
            nvmlDeviceGetHostVgpuMode,
            nvmlDeviceSetVirtualizationMode,
            nvmlDeviceGetGridLicensableFeatures_v3,
            nvmlDeviceGetProcessUtilization,
            nvmlDeviceGetSupportedVgpus,
            nvmlDeviceGetCreatableVgpus,
            nvmlVgpuTypeGetClass,
            nvmlVgpuTypeGetName,
            nvmlVgpuTypeGetDeviceID,
            nvmlVgpuTypeGetFramebufferSize,
            nvmlVgpuTypeGetNumDisplayHeads,
            nvmlVgpuTypeGetResolution,
            nvmlVgpuTypeGetLicense,
            nvmlVgpuTypeGetFrameRateLimit,
            nvmlVgpuTypeGetMaxInstances,
            nvmlVgpuTypeGetMaxInstancesPerVm,
            nvmlDeviceGetActiveVgpus,
            nvmlVgpuInstanceGetVmID,
            nvmlVgpuInstanceGetUUID,
            nvmlVgpuInstanceGetVmDriverVersion,
            nvmlVgpuInstanceGetFbUsage,
            nvmlVgpuInstanceGetLicenseStatus,
            nvmlVgpuInstanceGetType,
            nvmlVgpuInstanceGetFrameRateLimit,
            nvmlVgpuInstanceGetEccMode,
            nvmlVgpuInstanceGetEncoderCapacity,
            nvmlVgpuInstanceSetEncoderCapacity,
            nvmlVgpuInstanceGetEncoderStats,
            nvmlVgpuInstanceGetEncoderSessions,
            nvmlVgpuInstanceGetFBCStats,
            nvmlVgpuInstanceGetFBCSessions,
            nvmlVgpuInstanceGetMetadata,
            nvmlDeviceGetVgpuMetadata,
            nvmlGetVgpuCompatibility,
            nvmlDeviceGetPgpuMetadataString,
            nvmlGetVgpuVersion,
            nvmlSetVgpuVersion,
            nvmlDeviceGetVgpuUtilization,
            nvmlDeviceGetVgpuProcessUtilization,
            nvmlVgpuInstanceGetAccountingMode,
            nvmlVgpuInstanceGetAccountingPids,
            nvmlVgpuInstanceGetAccountingStats,
            nvmlVgpuInstanceClearAccountingPids,
            nvmlGetBlacklistDeviceCount,
            nvmlGetBlacklistDeviceInfoByIndex,
            nvmlDeviceSetMigMode,
            nvmlDeviceGetMigMode,
            nvmlDeviceGetGpuInstanceProfileInfo,
            nvmlDeviceGetGpuInstancePossiblePlacements,
            nvmlDeviceGetGpuInstanceRemainingCapacity,
            nvmlDeviceCreateGpuInstance,
            nvmlGpuInstanceDestroy,
            nvmlDeviceGetGpuInstances,
            nvmlDeviceGetGpuInstanceById,
            nvmlGpuInstanceGetInfo,
            nvmlGpuInstanceGetComputeInstanceProfileInfo,
            nvmlGpuInstanceGetComputeInstanceRemainingCapacity,
            nvmlGpuInstanceCreateComputeInstance,
            nvmlComputeInstanceDestroy,
            nvmlGpuInstanceGetComputeInstances,
            nvmlGpuInstanceGetComputeInstanceById,
            nvmlComputeInstanceGetInfo,
            nvmlDeviceIsMigDeviceHandle,
            nvmlDeviceGetGpuInstanceId,
            nvmlDeviceGetComputeInstanceId,
            nvmlDeviceGetMaxMigDeviceCount,
            nvmlDeviceGetMigDeviceHandleByIndex,
            nvmlDeviceGetDeviceHandleFromMigDeviceHandle,
        })
    }
    pub unsafe fn nvmlInit_v2(&self) -> nvmlReturn_t {
        (self
            .nvmlInit_v2
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn nvmlInitWithFlags(&self, flags: raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlInitWithFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    pub unsafe fn nvmlShutdown(&self) -> nvmlReturn_t {
        (self
            .nvmlShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn nvmlErrorString(&self, result: nvmlReturn_t) -> *const raw::c_char {
        (self
            .nvmlErrorString
            .as_ref()
            .expect("Expected function, got error."))(result)
    }
    pub unsafe fn nvmlSystemGetDriverVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(version, length)
    }
    pub unsafe fn nvmlSystemGetNVMLVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetNVMLVersion
            .as_ref()
            .expect("Expected function, got error."))(version, length)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetCudaDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion_v2(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetCudaDriverVersion_v2
            .as_ref()
            .expect("Expected function, got error."))(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetProcessName(
        &self,
        pid: raw::c_uint,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetProcessName
            .as_ref()
            .expect("Expected function, got error."))(pid, name, length)
    }
    pub unsafe fn nvmlUnitGetCount(&self, unitCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlUnitGetCount
            .as_ref()
            .expect("Expected function, got error."))(unitCount)
    }
    pub unsafe fn nvmlUnitGetHandleByIndex(
        &self,
        index: raw::c_uint,
        unit: *mut nvmlUnit_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetHandleByIndex
            .as_ref()
            .expect("Expected function, got error."))(index, unit)
    }
    pub unsafe fn nvmlUnitGetUnitInfo(
        &self,
        unit: nvmlUnit_t,
        info: *mut nvmlUnitInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetUnitInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, info)
    }
    pub unsafe fn nvmlUnitGetLedState(
        &self,
        unit: nvmlUnit_t,
        state: *mut nvmlLedState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetLedState
            .as_ref()
            .expect("Expected function, got error."))(unit, state)
    }
    pub unsafe fn nvmlUnitGetPsuInfo(
        &self,
        unit: nvmlUnit_t,
        psu: *mut nvmlPSUInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetPsuInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, psu)
    }
    pub unsafe fn nvmlUnitGetTemperature(
        &self,
        unit: nvmlUnit_t,
        type_: raw::c_uint,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetTemperature
            .as_ref()
            .expect("Expected function, got error."))(unit, type_, temp)
    }
    pub unsafe fn nvmlUnitGetFanSpeedInfo(
        &self,
        unit: nvmlUnit_t,
        fanSpeeds: *mut nvmlUnitFanSpeeds_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetFanSpeedInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, fanSpeeds)
    }
    pub unsafe fn nvmlUnitGetDevices(
        &self,
        unit: nvmlUnit_t,
        deviceCount: *mut raw::c_uint,
        devices: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetDevices
            .as_ref()
            .expect("Expected function, got error."))(unit, deviceCount, devices)
    }
    pub unsafe fn nvmlSystemGetHicVersion(
        &self,
        hwbcCount: *mut raw::c_uint,
        hwbcEntries: *mut nvmlHwbcEntry_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetHicVersion
            .as_ref()
            .expect("Expected function, got error."))(hwbcCount, hwbcEntries)
    }
    pub unsafe fn nvmlDeviceGetCount_v2(&self, deviceCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCount_v2
            .as_ref()
            .expect("Expected function, got error."))(deviceCount)
    }
    pub unsafe fn nvmlDeviceGetAttributes(
        &self,
        device: nvmlDevice_t,
        attributes: *mut nvmlDeviceAttributes_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(device, attributes)
    }
    pub unsafe fn nvmlDeviceGetHandleByIndex_v2(
        &self,
        index: raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByIndex_v2
            .as_ref()
            .expect("Expected function, got error."))(index, device)
    }
    pub unsafe fn nvmlDeviceGetHandleBySerial(
        &self,
        serial: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleBySerial
            .as_ref()
            .expect("Expected function, got error."))(serial, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByUUID(
        &self,
        uuid: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByUUID
            .as_ref()
            .expect("Expected function, got error."))(uuid, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByPciBusId_v2(
        &self,
        pciBusId: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByPciBusId_v2
            .as_ref()
            .expect("Expected function, got error."))(pciBusId, device)
    }
    pub unsafe fn nvmlDeviceGetName(
        &self,
        device: nvmlDevice_t,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetName
            .as_ref()
            .expect("Expected function, got error."))(device, name, length)
    }
    pub unsafe fn nvmlDeviceGetBrand(
        &self,
        device: nvmlDevice_t,
        type_: *mut nvmlBrandType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBrand
            .as_ref()
            .expect("Expected function, got error."))(device, type_)
    }
    pub unsafe fn nvmlDeviceGetIndex(
        &self,
        device: nvmlDevice_t,
        index: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetIndex
            .as_ref()
            .expect("Expected function, got error."))(device, index)
    }
    pub unsafe fn nvmlDeviceGetSerial(
        &self,
        device: nvmlDevice_t,
        serial: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSerial
            .as_ref()
            .expect("Expected function, got error."))(device, serial, length)
    }
    pub unsafe fn nvmlDeviceGetMemoryAffinity(
        &self,
        device: nvmlDevice_t,
        nodeSetSize: raw::c_uint,
        nodeSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryAffinity
            .as_ref()
            .expect("Expected function, got error."))(device, nodeSetSize, nodeSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinityWithinScope(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCpuAffinityWithinScope
            .as_ref()
            .expect("Expected function, got error."))(device, cpuSetSize, cpuSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinity(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device, cpuSetSize, cpuSet)
    }
    pub unsafe fn nvmlDeviceSetCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceClearCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetTopologyCommonAncestor(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        pathInfo: *mut nvmlGpuTopologyLevel_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTopologyCommonAncestor
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, pathInfo)
    }
    pub unsafe fn nvmlDeviceGetTopologyNearestGpus(
        &self,
        device: nvmlDevice_t,
        level: nvmlGpuTopologyLevel_t,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTopologyNearestGpus
            .as_ref()
            .expect("Expected function, got error."))(device, level, count, deviceArray)
    }
    pub unsafe fn nvmlSystemGetTopologyGpuSet(
        &self,
        cpuNumber: raw::c_uint,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetTopologyGpuSet
            .as_ref()
            .expect("Expected function, got error."))(cpuNumber, count, deviceArray)
    }
    pub unsafe fn nvmlDeviceGetP2PStatus(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        p2pIndex: nvmlGpuP2PCapsIndex_t,
        p2pStatus: *mut nvmlGpuP2PStatus_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetP2PStatus
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, p2pIndex, p2pStatus)
    }
    pub unsafe fn nvmlDeviceGetUUID(
        &self,
        device: nvmlDevice_t,
        uuid: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetUUID
            .as_ref()
            .expect("Expected function, got error."))(device, uuid, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetMdevUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mdevUuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetMdevUUID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, mdevUuid, size)
    }
    pub unsafe fn nvmlDeviceGetMinorNumber(
        &self,
        device: nvmlDevice_t,
        minorNumber: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMinorNumber
            .as_ref()
            .expect("Expected function, got error."))(device, minorNumber)
    }
    pub unsafe fn nvmlDeviceGetBoardPartNumber(
        &self,
        device: nvmlDevice_t,
        partNumber: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBoardPartNumber
            .as_ref()
            .expect("Expected function, got error."))(device, partNumber, length)
    }
    pub unsafe fn nvmlDeviceGetInforomVersion(
        &self,
        device: nvmlDevice_t,
        object: nvmlInforomObject_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomVersion
            .as_ref()
            .expect("Expected function, got error."))(device, object, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomImageVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomImageVersion
            .as_ref()
            .expect("Expected function, got error."))(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomConfigurationChecksum(
        &self,
        device: nvmlDevice_t,
        checksum: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomConfigurationChecksum
            .as_ref()
            .expect("Expected function, got error."))(device, checksum)
    }
    pub unsafe fn nvmlDeviceValidateInforom(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceValidateInforom
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetDisplayMode(
        &self,
        device: nvmlDevice_t,
        display: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDisplayMode
            .as_ref()
            .expect("Expected function, got error."))(device, display)
    }
    pub unsafe fn nvmlDeviceGetDisplayActive(
        &self,
        device: nvmlDevice_t,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDisplayActive
            .as_ref()
            .expect("Expected function, got error."))(device, isActive)
    }
    pub unsafe fn nvmlDeviceGetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPersistenceMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPciInfo_v3(
        &self,
        device: nvmlDevice_t,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPciInfo_v3
            .as_ref()
            .expect("Expected function, got error."))(device, pci)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        maxLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error."))(device, maxLinkGen)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        maxLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error."))(device, maxLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        currLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error."))(device, currLinkGen)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        currLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error."))(device, currLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetPcieThroughput(
        &self,
        device: nvmlDevice_t,
        counter: nvmlPcieUtilCounter_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieThroughput
            .as_ref()
            .expect("Expected function, got error."))(device, counter, value)
    }
    pub unsafe fn nvmlDeviceGetPcieReplayCounter(
        &self,
        device: nvmlDevice_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieReplayCounter
            .as_ref()
            .expect("Expected function, got error."))(device, value)
    }
    pub unsafe fn nvmlDeviceGetClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetClockInfo
            .as_ref()
            .expect("Expected function, got error."))(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetMaxClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxClockInfo
            .as_ref()
            .expect("Expected function, got error."))(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetApplicationsClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetDefaultApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDefaultApplicationsClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceResetApplicationsClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockId: nvmlClockId_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockId, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetMaxCustomerBoostClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxCustomerBoostClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedMemoryClocks(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedMemoryClocks
            .as_ref()
            .expect("Expected function, got error."))(device, count, clocksMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedGraphicsClocks(
        &self,
        device: nvmlDevice_t,
        memoryClockMHz: raw::c_uint,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedGraphicsClocks
            .as_ref()
            .expect("Expected function, got error."))(
            device, memoryClockMHz, count, clocksMHz
        )
    }
    pub unsafe fn nvmlDeviceGetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        isEnabled: *mut nvmlEnableState_t,
        defaultIsEnabled: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, isEnabled, defaultIsEnabled)
    }
    pub unsafe fn nvmlDeviceSetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, enabled)
    }
    pub unsafe fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetDefaultAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, enabled, flags)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed(
        &self,
        device: nvmlDevice_t,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFanSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, speed)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFanSpeed_v2
            .as_ref()
            .expect("Expected function, got error."))(device, fan, speed)
    }
    pub unsafe fn nvmlDeviceGetTemperature(
        &self,
        device: nvmlDevice_t,
        sensorType: nvmlTemperatureSensors_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTemperature
            .as_ref()
            .expect("Expected function, got error."))(device, sensorType, temp)
    }
    pub unsafe fn nvmlDeviceGetTemperatureThreshold(
        &self,
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTemperatureThreshold
            .as_ref()
            .expect("Expected function, got error."))(device, thresholdType, temp)
    }
    pub unsafe fn nvmlDeviceGetPerformanceState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPerformanceState
            .as_ref()
            .expect("Expected function, got error."))(device, pState)
    }
    pub unsafe fn nvmlDeviceGetCurrentClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        clocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrentClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error."))(device, clocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetSupportedClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        supportedClocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error."))(device, supportedClocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetPowerState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerState
            .as_ref()
            .expect("Expected function, got error."))(device, pState)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimitConstraints(
        &self,
        device: nvmlDevice_t,
        minLimit: *mut raw::c_uint,
        maxLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementLimitConstraints
            .as_ref()
            .expect("Expected function, got error."))(device, minLimit, maxLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementDefaultLimit(
        &self,
        device: nvmlDevice_t,
        defaultLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementDefaultLimit
            .as_ref()
            .expect("Expected function, got error."))(device, defaultLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerUsage(
        &self,
        device: nvmlDevice_t,
        power: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerUsage
            .as_ref()
            .expect("Expected function, got error."))(device, power)
    }
    pub unsafe fn nvmlDeviceGetTotalEnergyConsumption(
        &self,
        device: nvmlDevice_t,
        energy: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTotalEnergyConsumption
            .as_ref()
            .expect("Expected function, got error."))(device, energy)
    }
    pub unsafe fn nvmlDeviceGetEnforcedPowerLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEnforcedPowerLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceGetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlGpuOperationMode_t,
        pending: *mut nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetMemoryInfo(
        &self,
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryInfo
            .as_ref()
            .expect("Expected function, got error."))(device, memory)
    }
    pub unsafe fn nvmlDeviceGetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetCudaComputeCapability(
        &self,
        device: nvmlDevice_t,
        major: *mut raw::c_int,
        minor: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCudaComputeCapability
            .as_ref()
            .expect("Expected function, got error."))(device, major, minor)
    }
    pub unsafe fn nvmlDeviceGetEccMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlEnableState_t,
        pending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEccMode
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetBoardId(
        &self,
        device: nvmlDevice_t,
        boardId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBoardId
            .as_ref()
            .expect("Expected function, got error."))(device, boardId)
    }
    pub unsafe fn nvmlDeviceGetMultiGpuBoard(
        &self,
        device: nvmlDevice_t,
        multiGpuBool: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMultiGpuBoard
            .as_ref()
            .expect("Expected function, got error."))(device, multiGpuBool)
    }
    pub unsafe fn nvmlDeviceGetTotalEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTotalEccErrors
            .as_ref()
            .expect("Expected function, got error."))(
            device, errorType, counterType, eccCounts
        )
    }
    pub unsafe fn nvmlDeviceGetDetailedEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut nvmlEccErrorCounts_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDetailedEccErrors
            .as_ref()
            .expect("Expected function, got error."))(
            device, errorType, counterType, eccCounts
        )
    }
    pub unsafe fn nvmlDeviceGetMemoryErrorCounter(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        locationType: nvmlMemoryLocation_t,
        count: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryErrorCounter
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            errorType,
            counterType,
            locationType,
            count,
        )
    }
    pub unsafe fn nvmlDeviceGetUtilizationRates(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlUtilization_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetUtilizationRates
            .as_ref()
            .expect("Expected function, got error."))(device, utilization)
    }
    pub unsafe fn nvmlDeviceGetEncoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetEncoderCapacity(
        &self,
        device: nvmlDevice_t,
        encoderQueryType: nvmlEncoderType_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(
            device, encoderQueryType, encoderCapacity
        )
    }
    pub unsafe fn nvmlDeviceGetEncoderStats(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            sessionCount,
            averageFps,
            averageLatency,
        )
    }
    pub unsafe fn nvmlDeviceGetEncoderSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfos: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error."))(device, sessionCount, sessionInfos)
    }
    pub unsafe fn nvmlDeviceGetDecoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDecoderUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetFBCStats(
        &self,
        device: nvmlDevice_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFBCStats
            .as_ref()
            .expect("Expected function, got error."))(device, fbcStats)
    }
    pub unsafe fn nvmlDeviceGetFBCSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error."))(device, sessionCount, sessionInfo)
    }
    pub unsafe fn nvmlDeviceGetDriverModel(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlDriverModel_t,
        pending: *mut nvmlDriverModel_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDriverModel
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetVbiosVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVbiosVersion
            .as_ref()
            .expect("Expected function, got error."))(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetBridgeChipInfo(
        &self,
        device: nvmlDevice_t,
        bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBridgeChipInfo
            .as_ref()
            .expect("Expected function, got error."))(device, bridgeHierarchy)
    }
    pub unsafe fn nvmlDeviceGetComputeRunningProcesses(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeRunningProcesses
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceGetGraphicsRunningProcesses(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGraphicsRunningProcesses
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceOnSameBoard(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        onSameBoard: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceOnSameBoard
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, onSameBoard)
    }
    pub unsafe fn nvmlDeviceGetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAPIRestriction
            .as_ref()
            .expect("Expected function, got error."))(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceGetSamples(
        &self,
        device: nvmlDevice_t,
        type_: nvmlSamplingType_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        sampleCount: *mut raw::c_uint,
        samples: *mut nvmlSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSamples
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            type_,
            lastSeenTimeStamp,
            sampleValType,
            sampleCount,
            samples,
        )
    }
    pub unsafe fn nvmlDeviceGetBAR1MemoryInfo(
        &self,
        device: nvmlDevice_t,
        bar1Memory: *mut nvmlBAR1Memory_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBAR1MemoryInfo
            .as_ref()
            .expect("Expected function, got error."))(device, bar1Memory)
    }
    pub unsafe fn nvmlDeviceGetViolationStatus(
        &self,
        device: nvmlDevice_t,
        perfPolicyType: nvmlPerfPolicyType_t,
        violTime: *mut nvmlViolationTime_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetViolationStatus
            .as_ref()
            .expect("Expected function, got error."))(device, perfPolicyType, violTime)
    }
    pub unsafe fn nvmlDeviceGetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetAccountingStats(
        &self,
        device: nvmlDevice_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error."))(device, pid, stats)
    }
    pub unsafe fn nvmlDeviceGetAccountingPids(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(device, count, pids)
    }
    pub unsafe fn nvmlDeviceGetAccountingBufferSize(
        &self,
        device: nvmlDevice_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingBufferSize
            .as_ref()
            .expect("Expected function, got error."))(device, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPages
            .as_ref()
            .expect("Expected function, got error."))(device, cause, pageCount, addresses)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages_v2(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
        timestamps: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPages_v2
            .as_ref()
            .expect("Expected function, got error."))(
            device, cause, pageCount, addresses, timestamps,
        )
    }
    pub unsafe fn nvmlDeviceGetRetiredPagesPendingStatus(
        &self,
        device: nvmlDevice_t,
        isPending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPagesPendingStatus
            .as_ref()
            .expect("Expected function, got error."))(device, isPending)
    }
    pub unsafe fn nvmlDeviceGetRemappedRows(
        &self,
        device: nvmlDevice_t,
        corrRows: *mut raw::c_uint,
        uncRows: *mut raw::c_uint,
        isPending: *mut raw::c_uint,
        failureOccurred: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRemappedRows
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            corrRows,
            uncRows,
            isPending,
            failureOccurred,
        )
    }
    pub unsafe fn nvmlDeviceGetArchitecture(
        &self,
        device: nvmlDevice_t,
        arch: *mut nvmlDeviceArchitecture_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetArchitecture
            .as_ref()
            .expect("Expected function, got error."))(device, arch)
    }
    pub unsafe fn nvmlUnitSetLedState(
        &self,
        unit: nvmlUnit_t,
        color: nvmlLedColor_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitSetLedState
            .as_ref()
            .expect("Expected function, got error."))(unit, color)
    }
    pub unsafe fn nvmlDeviceSetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetPersistenceMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetComputeMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetEccMode(
        &self,
        device: nvmlDevice_t,
        ecc: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetEccMode
            .as_ref()
            .expect("Expected function, got error."))(device, ecc)
    }
    pub unsafe fn nvmlDeviceClearEccErrorCounts(
        &self,
        device: nvmlDevice_t,
        counterType: nvmlEccCounterType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearEccErrorCounts
            .as_ref()
            .expect("Expected function, got error."))(device, counterType)
    }
    pub unsafe fn nvmlDeviceSetDriverModel(
        &self,
        device: nvmlDevice_t,
        driverModel: nvmlDriverModel_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetDriverModel
            .as_ref()
            .expect("Expected function, got error."))(device, driverModel, flags)
    }
    pub unsafe fn nvmlDeviceSetGpuLockedClocks(
        &self,
        device: nvmlDevice_t,
        minGpuClockMHz: raw::c_uint,
        maxGpuClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device, minGpuClockMHz, maxGpuClockMHz)
    }
    pub unsafe fn nvmlDeviceResetGpuLockedClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceSetApplicationsClocks(
        &self,
        device: nvmlDevice_t,
        memClockMHz: raw::c_uint,
        graphicsClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error."))(device, memClockMHz, graphicsClockMHz)
    }
    pub unsafe fn nvmlDeviceSetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceSetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAPIRestriction
            .as_ref()
            .expect("Expected function, got error."))(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceSetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceClearAccountingPids(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetNvLinkState(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkState
            .as_ref()
            .expect("Expected function, got error."))(device, link, isActive)
    }
    pub unsafe fn nvmlDeviceGetNvLinkVersion(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        version: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkVersion
            .as_ref()
            .expect("Expected function, got error."))(device, link, version)
    }
    pub unsafe fn nvmlDeviceGetNvLinkCapability(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        capability: nvmlNvLinkCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkCapability
            .as_ref()
            .expect("Expected function, got error."))(device, link, capability, capResult)
    }
    pub unsafe fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkRemotePciInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(device, link, pci)
    }
    pub unsafe fn nvmlDeviceGetNvLinkErrorCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: nvmlNvLinkErrorCounter_t,
        counterValue: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkErrorCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, counterValue)
    }
    pub unsafe fn nvmlDeviceResetNvLinkErrorCounters(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetNvLinkErrorCounters
            .as_ref()
            .expect("Expected function, got error."))(device, link)
    }
    pub unsafe fn nvmlDeviceSetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
        reset: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, control, reset)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, control)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        rxcounter: *mut raw::c_ulonglong,
        txcounter: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(
            device, link, counter, rxcounter, txcounter
        )
    }
    pub unsafe fn nvmlDeviceFreezeNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        freeze: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceFreezeNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, freeze)
    }
    pub unsafe fn nvmlDeviceResetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter)
    }
    pub unsafe fn nvmlEventSetCreate(&self, set: *mut nvmlEventSet_t) -> nvmlReturn_t {
        (self
            .nvmlEventSetCreate
            .as_ref()
            .expect("Expected function, got error."))(set)
    }
    pub unsafe fn nvmlDeviceRegisterEvents(
        &self,
        device: nvmlDevice_t,
        eventTypes: raw::c_ulonglong,
        set: nvmlEventSet_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceRegisterEvents
            .as_ref()
            .expect("Expected function, got error."))(device, eventTypes, set)
    }
    pub unsafe fn nvmlDeviceGetSupportedEventTypes(
        &self,
        device: nvmlDevice_t,
        eventTypes: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedEventTypes
            .as_ref()
            .expect("Expected function, got error."))(device, eventTypes)
    }
    pub unsafe fn nvmlEventSetWait_v2(
        &self,
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlEventSetWait_v2
            .as_ref()
            .expect("Expected function, got error."))(set, data, timeoutms)
    }
    pub unsafe fn nvmlEventSetFree(&self, set: nvmlEventSet_t) -> nvmlReturn_t {
        (self
            .nvmlEventSetFree
            .as_ref()
            .expect("Expected function, got error."))(set)
    }
    pub unsafe fn nvmlDeviceModifyDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        newState: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceModifyDrainState
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, newState)
    }
    pub unsafe fn nvmlDeviceQueryDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        currentState: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceQueryDrainState
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, currentState)
    }
    pub unsafe fn nvmlDeviceRemoveGpu_v2(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        gpuState: nvmlDetachGpuState_t,
        linkState: nvmlPcieLinkState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceRemoveGpu_v2
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, gpuState, linkState)
    }
    pub unsafe fn nvmlDeviceDiscoverGpus(&self, pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceDiscoverGpus
            .as_ref()
            .expect("Expected function, got error."))(pciInfo)
    }
    pub unsafe fn nvmlDeviceGetFieldValues(
        &self,
        device: nvmlDevice_t,
        valuesCount: raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFieldValues
            .as_ref()
            .expect("Expected function, got error."))(device, valuesCount, values)
    }
    pub unsafe fn nvmlDeviceGetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error."))(device, pVirtualMode)
    }
    pub unsafe fn nvmlDeviceGetHostVgpuMode(
        &self,
        device: nvmlDevice_t,
        pHostVgpuMode: *mut nvmlHostVgpuMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHostVgpuMode
            .as_ref()
            .expect("Expected function, got error."))(device, pHostVgpuMode)
    }
    pub unsafe fn nvmlDeviceSetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        virtualMode: nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error."))(device, virtualMode)
    }
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures_v3(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGridLicensableFeatures_v3
            .as_ref()
            .expect("Expected function, got error."))(device, pGridLicensableFeatures)
    }
    pub unsafe fn nvmlDeviceGetProcessUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlProcessUtilizationSample_t,
        processSamplesCount: *mut raw::c_uint,
        lastSeenTimeStamp: raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetProcessUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            utilization,
            processSamplesCount,
            lastSeenTimeStamp,
        )
    }
    pub unsafe fn nvmlDeviceGetSupportedVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlDeviceGetCreatableVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCreatableVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlVgpuTypeGetClass(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeClass: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetClass
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuTypeClass, size)
    }
    pub unsafe fn nvmlVgpuTypeGetName(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeName: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetName
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuTypeName, size)
    }
    pub unsafe fn nvmlVgpuTypeGetDeviceID(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        deviceID: *mut raw::c_ulonglong,
        subsystemID: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetDeviceID
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, deviceID, subsystemID)
    }
    pub unsafe fn nvmlVgpuTypeGetFramebufferSize(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        fbSize: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetFramebufferSize
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, fbSize)
    }
    pub unsafe fn nvmlVgpuTypeGetNumDisplayHeads(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        numDisplayHeads: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetNumDisplayHeads
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, numDisplayHeads)
    }
    pub unsafe fn nvmlVgpuTypeGetResolution(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        displayIndex: raw::c_uint,
        xdim: *mut raw::c_uint,
        ydim: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetResolution
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, displayIndex, xdim, ydim)
    }
    pub unsafe fn nvmlVgpuTypeGetLicense(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeLicenseString: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetLicense
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuTypeId, vgpuTypeLicenseString, size
        )
    }
    pub unsafe fn nvmlVgpuTypeGetFrameRateLimit(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstances(
        &self,
        device: nvmlDevice_t,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCount: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetMaxInstances
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuTypeId, vgpuInstanceCount)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstancesPerVm(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCountPerVm: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetMaxInstancesPerVm
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuInstanceCountPerVm)
    }
    pub unsafe fn nvmlDeviceGetActiveVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuInstances: *mut nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetActiveVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuInstances)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vmId: *mut raw::c_char,
        size: raw::c_uint,
        vmIdType: *mut nvmlVgpuVmIdType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetVmID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vmId, size, vmIdType)
    }
    pub unsafe fn nvmlVgpuInstanceGetUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        uuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetUUID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, uuid, size)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmDriverVersion(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetVmDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, version, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetFbUsage(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbUsage: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFbUsage
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, fbUsage)
    }
    pub unsafe fn nvmlVgpuInstanceGetLicenseStatus(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        licensed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetLicenseStatus
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, licensed)
    }
    pub unsafe fn nvmlVgpuInstanceGetType(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuTypeId: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetType
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vgpuTypeId)
    }
    pub unsafe fn nvmlVgpuInstanceGetFrameRateLimit(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuInstanceGetEccMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        eccMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEccMode
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, eccMode)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceSetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceSetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance,
            sessionCount,
            averageFps,
            averageLatency,
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance, sessionCount, sessionInfo
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFBCStats
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, fbcStats)
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance, sessionCount, sessionInfo
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetMetadata(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetVgpuMetadata(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuMetadata
            .as_ref()
            .expect("Expected function, got error."))(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlGetVgpuCompatibility(
        &self,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetVgpuCompatibility
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuMetadata, pgpuMetadata, compatibilityInfo
        )
    }
    pub unsafe fn nvmlDeviceGetPgpuMetadataString(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut raw::c_char,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPgpuMetadataString
            .as_ref()
            .expect("Expected function, got error."))(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlGetVgpuVersion(
        &self,
        supported: *mut nvmlVgpuVersion_t,
        current: *mut nvmlVgpuVersion_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetVgpuVersion
            .as_ref()
            .expect("Expected function, got error."))(supported, current)
    }
    pub unsafe fn nvmlSetVgpuVersion(&self, vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t {
        (self
            .nvmlSetVgpuVersion
            .as_ref()
            .expect("Expected function, got error."))(vgpuVersion)
    }
    pub unsafe fn nvmlDeviceGetVgpuUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        vgpuInstanceSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            lastSeenTimeStamp,
            sampleValType,
            vgpuInstanceSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlDeviceGetVgpuProcessUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        vgpuProcessSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuProcessUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            lastSeenTimeStamp,
            vgpuProcessSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, mode)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, count, pids)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, pid, stats)
    }
    pub unsafe fn nvmlVgpuInstanceClearAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance)
    }
    pub unsafe fn nvmlGetBlacklistDeviceCount(
        &self,
        deviceCount: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetBlacklistDeviceCount
            .as_ref()
            .expect("Expected function, got error."))(deviceCount)
    }
    pub unsafe fn nvmlGetBlacklistDeviceInfoByIndex(
        &self,
        index: raw::c_uint,
        info: *mut nvmlBlacklistDeviceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetBlacklistDeviceInfoByIndex
            .as_ref()
            .expect("Expected function, got error."))(index, info)
    }
    pub unsafe fn nvmlDeviceSetMigMode(
        &self,
        device: nvmlDevice_t,
        mode: raw::c_uint,
        activationStatus: *mut nvmlReturn_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetMigMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode, activationStatus)
    }
    pub unsafe fn nvmlDeviceGetMigMode(
        &self,
        device: nvmlDevice_t,
        currentMode: *mut raw::c_uint,
        pendingMode: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMigMode
            .as_ref()
            .expect("Expected function, got error."))(device, currentMode, pendingMode)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceProfileInfo(
        &self,
        device: nvmlDevice_t,
        profile: raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error."))(device, profile, info)
    }
    pub unsafe fn nvmlDeviceGetGpuInstancePossiblePlacements(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        placements: *mut nvmlGpuInstancePlacement_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstancePossiblePlacements
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, placements, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceRemainingCapacity(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, count)
    }
    pub unsafe fn nvmlDeviceCreateGpuInstance(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceCreateGpuInstance
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, gpuInstance)
    }
    pub unsafe fn nvmlGpuInstanceDestroy(&self, gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceDestroy
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance)
    }
    pub unsafe fn nvmlDeviceGetGpuInstances(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstances: *mut nvmlGpuInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstances
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, gpuInstances, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceById(
        &self,
        device: nvmlDevice_t,
        id: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceById
            .as_ref()
            .expect("Expected function, got error."))(device, id, gpuInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        info: *mut nvmlGpuInstanceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetInfo
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profile: raw::c_uint,
        engProfile: raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, profile, engProfile, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, profileId, count)
    }
    pub unsafe fn nvmlGpuInstanceCreateComputeInstance(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceCreateComputeInstance
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance, profileId, computeInstance
        )
    }
    pub unsafe fn nvmlComputeInstanceDestroy(
        &self,
        computeInstance: nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlComputeInstanceDestroy
            .as_ref()
            .expect("Expected function, got error."))(computeInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstances(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstances: *mut nvmlComputeInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstances
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance,
            profileId,
            computeInstances,
            count,
        )
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceById(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        id: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceById
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, id, computeInstance)
    }
    pub unsafe fn nvmlComputeInstanceGetInfo(
        &self,
        computeInstance: nvmlComputeInstance_t,
        info: *mut nvmlComputeInstanceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlComputeInstanceGetInfo
            .as_ref()
            .expect("Expected function, got error."))(computeInstance, info)
    }
    pub unsafe fn nvmlDeviceIsMigDeviceHandle(
        &self,
        device: nvmlDevice_t,
        isMigDevice: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceIsMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error."))(device, isMigDevice)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceId
            .as_ref()
            .expect("Expected function, got error."))(device, id)
    }
    pub unsafe fn nvmlDeviceGetComputeInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeInstanceId
            .as_ref()
            .expect("Expected function, got error."))(device, id)
    }
    pub unsafe fn nvmlDeviceGetMaxMigDeviceCount(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxMigDeviceCount
            .as_ref()
            .expect("Expected function, got error."))(device, count)
    }
    pub unsafe fn nvmlDeviceGetMigDeviceHandleByIndex(
        &self,
        device: nvmlDevice_t,
        index: raw::c_uint,
        migDevice: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMigDeviceHandleByIndex
            .as_ref()
            .expect("Expected function, got error."))(device, index, migDevice)
    }
    pub unsafe fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
        &self,
        migDevice: nvmlDevice_t,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDeviceHandleFromMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error."))(migDevice, device)
    }
}
